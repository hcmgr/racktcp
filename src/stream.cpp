#include <random>
#include <sstream>
#include <cassert>

#include "stream.hpp"

#include "utils.hpp"
#include "crypto.hpp"

////////////////////////////////////////////
// SendStream methods
////////////////////////////////////////////
SendStream::SendStream(uint32_t bufferCapacity)
{
    // initialise send buffer
    sendBuffer.initialise(bufferCapacity);

    // set stream parameters
    ISS = generateISS();
    UNA = ISS;
    NXT = ISS + 1;
    WND = 0; // zero for now, update once we know peer's window

    // set r/w pointers
    sendBuffer.readPos = NXT;
    sendBuffer.writePos = NXT;
}

/**
 * Read into the to-be-sent payload `payload` the maximum number of 
 * available bytes in our send buffer.
 */
bool SendStream::readPayloadFromSendBuffer(std::vector<uint8_t> &payload)
{
    uint32_t maxAvailableBytes = sendBuffer.availableToRead();
    if (maxAvailableBytes == 0)
    {
        std::cout << "Failed send buffer read: no available bytes" << std::endl;
        return false;
    }

    payload.resize(maxAvailableBytes);
    sendBuffer.readN(payload, maxAvailableBytes, 0);
    return true;
}

/**
 * Generate a new initital sequence number (ISS).
 */
uint32_t SendStream::generateISS()
{
    /**
     * Our ISS is generated by taking the first 32 bits of
     * the SHA256 hash digest of:
     * 
     *      unix_epoch_time + random_offset
     * 
     * where:
     *      unix_epoch_time - 32-bit truncation of unix epoch time
     *      random_offset - 32-bit PRNG value
     * 
     * NOTE:
     * 
     * Performance issues could arise due to sha256's heavy duty'ness.
     * If so, consider trading off security for speed by swapping it our for 
     * a more light-weight hash function.
     */
    uint32_t unixEpochTime = TimeUtils::getUnixEpochTime();

    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_int_distribution<uint32_t> dis(0, UINT32_MAX);
    uint32_t randomOffset = dis(gen);

    uint32_t ISS = Crypto::sha256_32(unixEpochTime + randomOffset);
    return ISS;
}

std::string SendStream::toString()
{
    std::ostringstream oss;
    oss << "UNA: " << UNA << "\n"
        << "NXT: " << NXT << "\n"
        << "WND: " << WND << "\n"
        << "ISS: " << ISS << "\n";

    return oss.str();
}

////////////////////////////////////////////
// RecvStream methods
////////////////////////////////////////////
RecvStream::RecvStream(uint32_t bufferCapacity)
{
    // initialise receive buffer
    recvBuffer.initialise(bufferCapacity);

    // for now, set RCV.WND to its max (i.e. available write-space in buffer)
    // TODO: init to be determined by congestion control alg.
    WND = recvBuffer.availableToWrite();

    // zero these for now, update once we receive peer's ISS
    IRS = 0;
    NXT = 0;
}

/**
 * Write received `payload` to the receive buffer.
 */
bool RecvStream::writePayloadToRecvBuffer(std::vector<uint8_t> &payload)
{
    // write segment data
    if (!recvBuffer.writeN(payload, payload.size(), 0))
    {
        std::cout << "Failed recv buffer write: segment payload to large" << std::endl;
        return false;
    }

    // update stream state
    this->NXT = recvBuffer.writePos;
    this->WND = recvBuffer.availableToWrite();

    return true;
}

std::string RecvStream::toString()
{
    std::ostringstream oss;
    oss << "NXT: " << NXT << "\n"
        << "WND: " << WND << "\n"
        << "IRS: " << IRS << "\n";

    return oss.str();
}
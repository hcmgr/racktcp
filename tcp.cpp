#include <unistd.h>
#include <netinet/ip.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <mutex>
#include <memory>
#include <string.h>
#include <iterator>
#include <sstream>
#include <iomanip>
#include <random>

#include "tcp.hpp"
#include "ip.hpp"
#include "buffer.hpp"
#include "utils.hpp"
#include "crypto.hpp"
#include "config.hpp"
#include "packet.hpp"

////////////////////////////////////////////
// TcpHeader methods
////////////////////////////////////////////
std::string TcpHeader::toString()
{
    std::ostringstream oss;

    oss << "TCP Header" << "\n\n";
    oss << "  Source Port: " << sourcePort << "\n";
    oss << "  Destination Port: " << destPort << "\n";

    oss << "  Sequence Number: " << seqNum << "\n";
    oss << "  Acknowledgment Number: " << ackNum << "\n";

    oss << "  Data Offset: " << static_cast<int>(doff) << " (words)" << "\n";

    oss << "  Flags: [";
    if (FIN) oss << "FIN: " << FIN << ", ";
    if (SYN) oss << "SYN: " << SYN << ", ";
    if (RST) oss << "RST: " << RST << ", ";
    if (PSH) oss << "PSH: " << PSH << ", ";
    if (ACK) oss << "ACK: " << ACK << ", ";
    if (URG) oss << "URG: " << URG;
    oss << "]" << "\n";

    oss << "  Window Size: " << window << "\n";
    oss << "  Checksum: 0x" << std::hex << std::setw(4) << std::setfill('0') << checksum << std::dec << "\n";
    oss << "  Urgent Pointer: " << urgPtr << "\n";

    return oss.str();
}

void TcpHeader::networkToHostOrder()
{
    sourcePort = ntohs(sourcePort);
    destPort = ntohs(destPort);
    seqNum = ntohl(seqNum);
    ackNum = ntohl(ackNum);
    window = ntohs(window);
    checksum = ntohs(checksum);
    urgPtr = ntohs(urgPtr);
}

void TcpHeader::hostToNetworkOrder()
{
    sourcePort = htons(sourcePort);
    destPort = htons(destPort);
    seqNum = htonl(seqNum);
    ackNum = htonl(ackNum);
    window = htons(window);
    checksum = htons(checksum);
    urgPtr = htons(urgPtr);
}

////////////////////////////////////////////
// SendStream methods
////////////////////////////////////////////
SendStream::SendStream(uint32_t bufferCapacity)
{
    // initialise send buffer
    sendBuffer.initialise(bufferCapacity);

    // set stream parameters
    ISS = generateISS();
    UNA = ISS;
    NXT = ISS + 1;
    WND = 0; // zero for now, update once we know peer's window

    // set r/w pointers
    sendBuffer.readPos = NXT;
    sendBuffer.writePos = NXT;
}

/**
 * Generate a new initital sequence number (ISS).
 */
uint32_t SendStream::generateISS()
{
    /**
     * Our ISS is generated by taking the first 32 bits of
     * the SHA256 hash digest of:
     * 
     *      unix_epoch_time + random_offset
     * 
     * where:
     *      unix_epoch_time - 32-bit truncation of unix epoch time
     *      random_offset - 32-bit PRNG value
     * 
     * NOTE:
     * 
     * Performance issues could arise due to sha256's heavy duty'ness.
     * If so, consider trading off security for speed by swapping it our for 
     * something more light weight.
     */
    uint32_t unixEpochTime = Time::getUnixEpochTime();

    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_int_distribution<uint32_t> dis(0, UINT32_MAX);
    uint32_t randomOffset = dis(gen);

    uint32_t ISS = Crypto::sha256_32(unixEpochTime + randomOffset);
    return ISS;
}

std::string SendStream::toString()
{
    std::ostringstream oss;
    oss << "UNA: " << UNA << "\n"
        << "NXT: " << NXT << "\n"
        << "WND: " << WND << "\n"
        << "ISS: " << ISS << "\n";

    return oss.str();
}

////////////////////////////////////////////
// RecvStream methods
////////////////////////////////////////////
RecvStream::RecvStream(uint32_t bufferCapacity)
{
    // initialise receive buffer
    recvBuffer.initialise(bufferCapacity);

    // for now, set RCV.WND to its max (i.e. available write-space in buffer)
    // TODO: init to be determined by congestion control alg.
    WND = recvBuffer.availableToWrite();

    // zero these for now, update once we receive peer's ISS
    IRS = 0;
    NXT = 0;
}

std::string RecvStream::toString()
{
    std::ostringstream oss;
    oss << "NXT: " << NXT << "\n"
        << "WND: " << WND << "\n"
        << "IRS: " << IRS << "\n";

    return oss.str();
}



/**
 * Represents the TCP thread responsible for sending/receiving packets,
 * and updating the state accordingly.
 * 
 * Given we are doing this in userland, this separate thread mimics the role
 * that the kernel process plays in usual TCP stacks.
 */
class SegmentThread
{
public:
    SegmentThread(std::shared_ptr<Tcb> tcb)
    {
        this->tcb = tcb;
        this->sock = initialiseRawSocket();
        if (this->sock < 0)
            throw std::runtime_error("Failed socket creation");
        return;
    }

    void startThread()
    {
        run();
    }

private:
    /**
     * Transmission Control Block (TCB) of this connection.
     */
    std::shared_ptr<Tcb> tcb;

    /**
     * Raw IP socket of this connection.
     */
    int sock;

    /**
     * Opens and initialises this connection's raw IP socket.
     */
    int initialiseRawSocket()
    {
        int sock = socket(AF_INET, SOCK_RAW, IPPROTO_TCP);
        if (sock < 0)
        {
            perror("Failed socket creation");
            return -1;
        }

        /**
         * Bind to destination addr
         */
        struct sockaddr_in destAddr;
        destAddr.sin_family = AF_INET;
        destAddr.sin_addr.s_addr = inet_addr(tcb->sourceAddr.c_str());
        socklen_t destAddrLen = sizeof(destAddr);

        if (bind(sock, (struct sockaddr*)&destAddr, destAddrLen))
        {
            perror("Failed bind");
            return -1;
        }

        return sock;
    }

    /**
     * Retreive a packet from `packetBuffer`, which holds the most
     * recent packet from the raw IP socket.
     */
    ssize_t retreivePacket(std::vector<uint8_t>& packetBuffer)
    {
        ssize_t packetSize = recvfrom(
            sock, 
            packetBuffer.data(), 
            packetBuffer.size(),
            0, 
            NULL, 
            NULL
        );

        if (packetSize < 0 || packetSize > packetBuffer.size())
        {
            perror("Packet receive failed");
            return -1;
        }

        return packetSize;
    }

    /**
     * Send `packet` to the connection's raw IP socket.
     */
    ssize_t sendPacket(Packet &packet, bool includeIpHeader = false)
    {
        std::vector<uint8_t> packetBuffer = packet.serialise(includeIpHeader);

        // destination info
        struct sockaddr_in destAddr;
        destAddr.sin_family = AF_INET;
        destAddr.sin_port = htons(tcb->destPort);
        destAddr.sin_addr.s_addr = inet_addr(tcb->destAddr.c_str());

        ssize_t bytesSent = sendto(
            sock,
            packetBuffer.data(),
            packetBuffer.size(),
            0,
            (struct sockaddr*)&destAddr,
            sizeof(destAddr)
        );

        if (bytesSent < 0 || bytesSent != packetBuffer.size())
        {
            perror("sendto() failed");
            return -1;
        }
        return bytesSent;
    }

    void closedHandler()
    {
        std::cout << "CLOSED: sending initial SYN" << std::endl;
        std::cout << tcb->sendStream.toString() << std::endl;

        /**
         * Send initial SYN packet
         */
        TcpHeader h = {};
        h.sourcePort = tcb->sourcePort;
        h.destPort = tcb->destPort;
        h.doff = sizeof(h) / 4;

        // advertise ISS and window size
        h.SYN = 1;
        h.seqNum = tcb->sendStream.ISS;
        h.window = tcb->recvStream.WND;

        Packet packet;
        packet.tcpHeader = h;

        sendPacket(packet);

        // transition to SYN-RECEIVED state
        tcb->state = SYN_SENT;
    }

    void listenHandler(TcpHeader segHdr)
    {
        std::cout << tcb->sendStream.toString() << std::endl;

        // received initial SYN
        if (segHdr.SYN)
        {
            std::cout << "LISTEN: received SYN" << std::endl;

            // initialse recv stream based on peer's ISS and window size
            tcb->recvStream.IRS = segHdr.seqNum;
            tcb->recvStream.NXT = segHdr.seqNum + 1;
            tcb->recvStream.WND = segHdr.window;

            /**
             * Build and send SYN-ACK
             */
            TcpHeader hdr = {};
            hdr.sourcePort = tcb->sourcePort;
            hdr.destPort = tcb->destPort;
            hdr.doff = sizeof(hdr) / 4;

            // advertise ISS and window size
            hdr.SYN = 1;
            hdr.seqNum = tcb->sendStream.ISS;
            hdr.window = tcb->recvStream.WND;

            // acknowledge peer's ISS
            hdr.ACK = 1;
            hdr.ackNum = tcb->recvStream.NXT;

            Packet packet;
            packet.tcpHeader = hdr;

            sendPacket(packet);

            // transition to SYN-RECEIVED state
            tcb->state = SYN_RECEIVED;
        }

        else 
        {
            /**
             * TODO: 
             * 
             * As we are in the LISTEN state, we reply to any
             * non-SYN packets with a RST. 
             */
            std::cout << "LISTEN: non-SYN received, send RST" << std::endl;
        }
    }

    void synSentHandler(TcpHeader segHdr)
    {
        // received SYN-ACK
        if (segHdr.SYN && segHdr.ACK)
        {
            std::cout << "SYN-SENT: received SYN-ACK" << std::endl;

            /**
             * Validate ack. num. is correct.
             * 
             * NOTE: 
             * 
             * We don't send any data whilst connection is being
             * established, so: 
             *      SEG.ACK == SND.NXT == ISS + 1
             * should hold.
             */
            if (!(segHdr.ackNum == tcb->sendStream.NXT && 
                  segHdr.ackNum == tcb->sendStream.ISS + 1))
            {
                std::cout << "SYN-SENT: bad ack, send RST, -> CLOSED" << std::endl;
                std::cout << segHdr.ackNum << " " 
                          << tcb->sendStream.NXT << " " 
                          << tcb->sendStream.ISS + 1 
                          << std::endl;
                return;
            }

            // initialise recv stream based on peer's ISS and window size
            tcb->recvStream.IRS = segHdr.seqNum;
            tcb->recvStream.NXT = segHdr.seqNum + 1;
            tcb->recvStream.WND = segHdr.window;

            /**
             * Send ACK
             */
            TcpHeader hdr = {};
            hdr.sourcePort = tcb->sourcePort;
            hdr.destPort = tcb->destPort;
            hdr.doff = sizeof(hdr) / 4;

            // acknowledge peer's ISS and window size
            hdr.ACK = 1;
            hdr.ackNum = tcb->recvStream.NXT;

            Packet packet;
            packet.tcpHeader = hdr;

            sendPacket(packet);

            // transition to established state
            tcb->state = ESTABLISHED;
            std::cout << "Connection established" << std::endl;
        }
    }

    void synReceivedHandler(TcpHeader segHdr)
    {
        // received ACK
        if (segHdr.ACK)
        {
            std::cout << "SYN-RECEIVED: received ACK" << std::endl;

            /**
             * Validate ack. num. is correct. 
             * 
             * NOTE:
             * 
             * See synSentHandler (above) for explanation of validation.
             */
            if (!(segHdr.ackNum == tcb->sendStream.NXT && 
                  segHdr.ackNum == tcb->sendStream.ISS + 1))
            {
                std::cout << "SYN-RECEIVED: bad ack, send RST, -> LISTEN" << std::endl;
                std::cout << segHdr.ackNum << " " 
                          << tcb->sendStream.NXT << " " 
                          << tcb->sendStream.ISS + 1 
                          << std::endl;
                return;
            }

            tcb->state = ESTABLISHED;
            std::cout << "Connection established" << std::endl;
        }
    }

    void establishedHandler(Packet &recvPacket)
    {
        std::cout << "ESTABLISHED: received packet" << std::endl;

        /**
         * Process incoming packet
         */

        /**
         * Send reply packet
         */
        Packet replyPacket;

        TcpHeader hdr = {};
        hdr.sourcePort = tcb->sourcePort;
        hdr.destPort = tcb->destPort;
        hdr.doff = sizeof(hdr) / 4;

        replyPacket.tcpHeader = hdr;

        std::string msg("Hello there!");
        replyPacket.payload.resize(msg.size());
        std::copy(msg.begin(), msg.end(), replyPacket.payload.data());

        sendPacket(replyPacket);
    }

    bool packetValid(Packet &packet)
    {
        return (
            packet.ipHeader.saddr == inet_addr(tcb->destAddr.c_str()) &&
            packet.ipHeader.daddr == inet_addr(tcb->sourceAddr.c_str()) &&
            packet.tcpHeader.sourcePort == tcb->destPort &&
            packet.tcpHeader.destPort == tcb->sourcePort
        );
    }

    void run()
    {
        std::vector<uint8_t> packetBuffer(MTU);
        
        while (1)
        {
            Packet packet;

            bool waitForPacket = true;
            if (tcb->state == CLOSED)
                waitForPacket = false;

            if (waitForPacket)
            {
                ssize_t packetSize = retreivePacket(packetBuffer);

                if (packetSize < 0) 
                    return;
                
                packet = Packet::deserialise(packetBuffer, packetSize);

                if (!packetValid(packet))
                    continue;
                
                std::cout << packet.toString(false, true) << std::endl;
            }
            
            switch(tcb->state)
            {
                case CLOSED:
                    closedHandler();
                    break;
                case LISTEN:
                    listenHandler(packet.tcpHeader);
                    break;
                case SYN_SENT:
                    synSentHandler(packet.tcpHeader);
                    break;
                case SYN_RECEIVED:
                    synReceivedHandler(packet.tcpHeader);
                    break;
                case ESTABLISHED:
                    establishedHandler(packet);
                    break;
                default:
                    // shouldn't reach here
                    throw std::runtime_error("Undefined state reached");
            }
        }
    }
};

int main()
{
    std::string ip = "10.126.0.2";
    auto tcb = std::make_shared<Tcb>();

#ifdef THREAD1
    tcb->state = CLOSED;
    tcb->sourceAddr = ip;
    tcb->sourcePort = 8100;
    tcb->destAddr = ip;
    tcb->destPort = 8101;
#else // THREAD2
    tcb->state = LISTEN;
    tcb->sourceAddr = ip;
    tcb->sourcePort = 8101;
    tcb->destAddr = ip;
    tcb->destPort = 8100;
#endif

    SegmentThread st(tcb);
    st.startThread();
}